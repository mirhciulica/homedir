#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Feature full netcfg management script for openbox
mirhciulica 2011

requires:
    wpa_supplicant (already running in background before calling this script)
    wpa_cli
    netcfg
    NOPASSWD entries for this script through visudo

changelog
    01.2011
      + initial work for openbox menu output
    02.2011
      + wireless networks scan with wpa_supplicant & wpa_cli
      + change ethernet network profile from openbox menu
      * code cleanup
      + wireless profiles auto generation
      + connect to wireless networks
"""


from getopt import getopt, GetoptError
from operator import itemgetter
from subprocess import call, check_output
from os import listdir, path
from time import sleep
import sys


profiles_path = '/etc/network.d/'
profiles = {'ethernet':[], 'wireless':[]}

def get_network_profiles():
    scan_output = check_output(['wpa_cli', '-i', 'wlan0', 'scan'])
    #sleep(1)
    scan_results = check_output(['wpa_cli', '-i', 'wlan0', 'scan_results']).decode()
    results_array = scan_results[scan_results.find('\n')+1:].splitlines()
    results_array = [l[23:].split('\t') for l in results_array]
    newlist = []
    append = newlist.append
    for array in results_array:
        array = [array[2], array[1], int((int(array[0])+100)*10/6)]
        if array[1].startswith('[WPA'):
            array[1] = 'wpa'
        elif array[1].startswith('[WEP'):
            if array[1].endswith('[ESS]'):
                array[1] = 'wep'
            elif array[1].endswith('[IBSS]'):
                array[2] = 'wep-adhoc'
        elif array[1] == '[ESS]':
            array[1] = 'none'
        elif array[1] == '[IBSS]':
            array[1] = 'none-adhoc'
        append(array)
    newlist.sort(key=itemgetter(2), reverse=True)
    profiles['wireless'] = newlist

    tempFile = open('/tmp/wifi-networks', 'w')
    tempFile.writelines(['%s%s\n' % (p[0], p[1]) for p in profiles['wireless']])
    tempFile.close()

    profiles_array = listdir(profiles_path)
    isdir = path.isdir
    newlist = []
    append = newlist.append
    for profile in profiles_array:
        profile_path = profiles_path+profile
        if isdir(profile_path):
            continue
        file_object = open(profile_path)
        head = file_object.readline()
        if head[12:-2] == 'ethernet':
            append(profile)
    profiles['ethernet'] = newlist

def get_openbox_pipe_menu():
    script_path = path.abspath(__file__)
    curr_conn = current_conn()
    menu_sep = '\n<separator label="%s" />'
    menu_item = '\n<item label="%s"> \
                   \n<action name="Execute"> \
                     \n<command>sudo %s</command> \
                   \n</action> \
                 \n</item>'
    output = []
    append = output.append
    extend = output.extend
    append('<openbox_pipe_menu>')
    append(menu_sep % 'Current profile')
    append(menu_item % (curr_conn, ''))
    if not curr_conn == 'none':
        append(menu_item % ('Disconnect', '%s -a down' % script_path))
    if is_plugged('eth0'):
        append(menu_sep % 'Available ethernet networks')
        extend([menu_item % (p,'%s -a up -t "%s"' % (script_path, p)) \
                for p in profiles['ethernet']])
    append(menu_sep % 'Available wireless networks')
    extend([menu_item % ('%s (%s) %d%%' % (p[0], p[1], p[2]), \
            '%s -a up -t "%s"' % (script_path, p)) \
            for p in profiles['wireless']])
    append('\n</openbox_pipe_menu>')
    return ''.join(output)

def is_plugged(interface):
    carrier_file = open('/sys/class/net/%s/carrier' % interface)
    if carrier_file.read().startswith('1'):
        return True
    return False

def current_conn():
    current = check_output(['netcfg', 'current']).decode()
    if not len(current) == 0:
        return current[:-1]
    return 'none'

def take_down_current_profile():
    call(['netcfg', 'down', current_conn()])

def take_up_profile(profile):
    security = ''
    tempFile = open('/tmp/wifi-networks', 'r')
    tempList = tempFile.readlines()
    tempFile.close()
    for s in tempList:
        if s.startswith(profile):
            security = s[len(profile):]
            security = security[:security.find('-')]
            break
    key = ''
    profileList = []
    if not path.isfile('/etc/network.d/%s' % profile):
        retcode = call(['touch', '/etc/networkd.d/%s' % profile])
    elif not security == 'none':
        tempFile = open('/etc/network.d/%s' % profile, 'r')
        profileList = tempFile.readlines()
        profileList.reverse()
        tempFile.close()
        for s in profileList:
            if s.startswith('KEY='):
                key = s[s.find('"')+1:s.rfind('"')]
                break
    if not security == 'none' and key == '':
        key = check_output(['zenity', '--entry', '--title', \
                'Authentication', '--text', \
                'Please enter %s key for %s' % (security, profile), \
                '--hide-text']).decode()[:-1]
    create_profile(profile, 'wlan0', security, key)
    call(['netcfg', 'up', profile])

def create_profile(essid, interface, security, key):
    profile = [
            'CONNECTION="wireless"\n',
            'ESSID="%s"\n' % essid,
            'INTERFACE="%s"\n' % interface,
            'DESCRIPTION="Automatically generated profile"\n',
            'SCAN="yes"\n',
            'IP="dhcp"\n',
            'TIMEOUT="15"\n',
            'SECURITY="%s"\n' % security,
            ]
    if not security == 'none':
        profile.append('KEY="%s"' % key)
    profileFile = open('/etc/network.d/%s' % essid, 'w')
    profileFile.writelines(profile)
    profileFile.close()


def usage():
    print('test')

if __name__ == "__main__":
    get_network_profiles()
    action = 'menu'
    try:
        opts, args = getopt(sys.argv[1:],'a:t:',[])
    except GetoptError:
        usage()
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-a':
            action = arg
        if opt == '-t':
            target = arg

    if action == 'menu':
        print(get_openbox_pipe_menu())
    elif action == 'down':
        take_down_current_profile()
    elif action == 'up':
        take_up_profile(target)

